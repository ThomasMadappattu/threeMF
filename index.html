<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>threeMF - A framework for easy ad-hoc device discovery and RPC based communication.</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <img src="images/3mf.png" />
        <p>A framework for easy ad-hoc device discovery and RPC based communication.</p>
        <p class="view"><a href="http://threemf.com/documentation/">View code documentaion <small>http://threemf.com/documentation</small></a></p>
        <p class="view"><a href="https://github.com/threeMF/threeMF">View the Project on GitHub <small>threeMF/threeMF</small></a></p>
      </header>
      <section>
      <h1>threeMF</h1>
      <p>The Mobile MultiModal (Interaction) Framework (3MF or threeMF) is a <strong>generic</strong> and <strong>extendable</strong> ad-hoc networking framework for <strong>easy device discovery</strong>, <strong>capability checking</strong> and pattern based <strong>RPC communication</strong>.</p>

      <p>3MF allows ad-hoc communication between devices, without the pain of handling <strong>service discovery and management</strong>, network <strong>socket</strong> and <strong>disconnection handling</strong> as well as <strong>data serialization</strong>. Data exchange is abstracted with simple patterns which reduce code complexity to a few lines. To fit a wide range of use cases the framework is very generic and extendable.</p>

      <h2>How does it work</h2>
      <p>3MF creates a P2P network to share ad-hoc network services between devices. Discovery of remote 3MF instances, their management during visibility and disappearance is handled automatically. Each peer can publish <a href="http://en.wikipedia.org/wiki/Remote_procedure_call">remote procedures</a> (they are called commands in the context of 3MF) and execute them at each other. These commands are a semantic description defining <strong>which data</strong> gets shared on <strong>which network channel</strong> (TCP, UDP, &#8230;) following <strong>which pattern</strong> (<a href="https://github.com/threeMF/threeMF/wiki/ResponseRequest">Response Request</a> or <a href="https://github.com/threeMF/threeMF/wiki/PublishSubscribe">Publish Subscribe</a>).</p>

      <p><strong>Response Request</strong> (RR) commands define remote procedures delivering a <strong>response</strong> for a list of defined parameters on <strong>request</strong>. An example would be a computer asking a mobile phone for it&#8217;s current GPS location.</p>
      <div class="img"><img src="images/request_response.png" /></div>

      <p><strong>Publish Subscribe</strong> (PS) commands on the other hand get triggered by the <strong>publisher</strong> whenever a defined event occurs. Other peers can <strong>subscribe</strong> to PS commands and get payload <strong>pushed</strong>. Messages send to subscribers will not create responses, they are just notifications for subscribers. An example would be a mobile phone with motion sensors providing a command for real time accelerometer data sharing.</p>
      <div class="img"><img src="images/publish_subscribe.png" /></div>

      <p>3MF comes with <a href="https://github.com/threeMF/threeMF/wiki/BuildInCommands">build-in commands</a> --- but it's real power lies in it's extendability. You are able to customize nearby every part, starting at <a href="https://github.com/threeMF/threeMF/wiki/CustomCommands">custom commands</a> over to <a href="https://github.com/threeMF/threeMF/wiki/CustomNewtorkChannels">network channels</a> and <a href="https://github.com/trheeMF/threeMF/wiki/CustomProtocols">communication protocols</a>.</p>

      <p>The framework communicates <strong>ad-hoc</strong>, which means it is sending network messages directly between peers using their local network without a central instance.</p>
      <h2>Examlples</h2>
      <h3>Publish Subscribe Example</h3>
      <p>The following code snippets show how to <strong>publish</strong> a command and <strong>discover</strong> peers providing it, to <strong>subscribe</strong>, and finally how payload is <strong>pushed</strong> to subscribers. </p>

      <h4>Scenario</h4>
      <p>Peer A provides a command pushing arbitrary key value pairs to subscribers. Peer B searches for peers serving the command and subscribes. Peer A will than start pushing payload causing Peer B's receive block to execute until the session ends.</p>

      <ol>
        <li>Publish the <code>TMFKeyValueCommand</code>. (Peer A)</li>
        <li>Discover peers providing the command. (Peer B)</li>
        <li>Subscribe to the command at discovered peers. (Peer B)</li>
        <li>Push key value pairs to all subscribers. (Peer A)</li>
      </ol>

      <h4>Step 0: Setup (Peer A and Peer B)</h4>
      <pre><code>#import "threeMF.h"
self.tmf = [TMFConnector new];</code></pre>

      <h4>Step 1: Provide (Peer A)</h4>
      <pre><code>self.kvCmd = [TMFKeyValueCommand new];[self.tmf publishCommand:self.kvCmd];</code></pre>

      <h4>Step 2: Discover (Peer B)</h4>
      <pre><code>[self.tmf startDiscoveryWithCapabilities:@[ [TMFKeyValueCommand class] ] delegate:self];</code></pre>

      <h4>Step 3: Subscribe (Peer B)</h4>
      <pre><code>- (void)threeMF:(TMFConnector *)tmf didChangeDiscoveringPeer:(TMFPeer *)peer forChangeType:(TMFPeerChangeType)type {
            if(type == TMFPeerChangeFound) {
                 [self.tmf subscribe:[TMFKeyValueCommand class] peer:peer receive:^(TMFKeyValueCommandArguments *arguments){
                 // do awesome things
                 NSLog(@"%@: %@", arguments.key, arguments.value);
            }
            completion:^(NSError *error){
                 if(error) { // handle error
                     NSLog(@"%@", error);
                 }
            }];
          }
      }</code></pre>

      <h4>Step 4: Execute (Peer A)</h4>
      <pre><code>TMFKeyValueCommandArguments *kvArguments = [TMFKeyValueCommandArguments new];
kvArguments.key = @"msg";
kvArguments.value = @"Hello World!";
[self.kvCmd sendWithArguments:kvArguments];</code></pre>

			<h3>Request Response Example</h3>

			<p>Request Response commands are a bit simpler. Setup, providing and discovery are equal to the Publish Subscribe scenario and the subscribe step is not available. The execution differs because the requester executes the command. This sends all parameters (may be optional) to the provider where request get processed followed by a result returned as response (asynchronously).

			<pre><code>CADAnnounceCommandArguments *args = [CADAnnounceCommandArguments new];
 args.name = @"Arthur Dent";
 args.color = @"#424242";

[self.tmf sendCommand:[CADAnnounceCommand class] arguments:args destination:peer
 response:^(id response, TMFPeer *peer, NSError *error){
 // handle response or error
 }];
</code></pre>

      <h2>Platform</h2>
      <p>3MF is currently implemented in <a href="https://developer.apple.com/cocoa/">Cocoa</a> running on iOS and OSX. The bigger vision is to have a system also spread across other platforms like Android, Windows Phone, ... you name it. Feel free to contact <a href="http://twitter.com/mgratzer">me</a>, if you'r interested in porting 3MF --- I'm glad to provide help if needed.</p>

      <h2>Thanks</h2>
      <p>3MF uses the great <a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> library for it's build-in <a href="http://threemf.com/documentation/Classes/TMFTcpChannel.html">TCP</a> and <a href="http://threemf.com/documentation/Classes/TMFUdpChannel.html">UDP</a> network channels and the Base64 encoding part from <a href="https://github.com/sprhawk/ytoolkit">ytoolkit</a> to encode binary data. JSON-RPC is the default communication protocol, but there is also a <a href="http://threemf.com/documentation/Classes/TMFMsgPackRpcCoder.html">coding class</a> using the <a href="https://github.com/msgpack/msgpack-objectivec">MsgPack-ObjectiveC</a> for <a href="https://github.com/threeMF/threeMF/wiki/MsgPack-RPC">MsgPack-RPC</a>.</p>

      </section>
      <footer>
	      <p><small>threeMF is available under the MIT license.</small></p>
        <p><small>This project is maintained by <a href="http://www.mgratzer.com">mgratzer</a>.<br/>Development supported by the <a href="http://www.uni-klu.ac.at/tewi/inf/isys/ias/index.html">Interactive Systems research group</a> at the University of Klagenfurt under the supervision of <a href="http://www.bonifazkaufmann.com">Bonifaz Kaufmann</a> and <a href="http://martin.hitz-koenigsbauer.net">Martin Hitz</a>.</small></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a>.</small></p>
      </footer>
    </div>

    <script type="text/javascript" src="/js/retina.js"></script>
    <script src="javascripts/scale.fix.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-15886208-5");
          pageTracker._trackPageview();
        } catch(err) {}
    </script>
  </body>
</html>